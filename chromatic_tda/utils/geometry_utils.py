import numpy as np

from chromatic_tda.utils.linear_algebra_utils import LinAlgUtils
from chromatic_tda.utils.timing import TimingUtils


class GeometryUtils:
    @staticmethod
    def construct_equispace(*point_sets: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
        """Return the 'point + vector space' representation of the affine space A of points
        equidistant to all points of each argument. That is for a in A and for each argument P,
        all distances ||p - a|| for p in P are the same.

        :return: center `z`, list of generating vectors `ker`"""
        TimingUtils().start("Geom :: Construct Equispace")
        if len(point_sets) < 1:
            raise TypeError("At least one point set expected.")
        dim: int = point_sets[0].shape[1]
        k: int = len(point_sets)

        for point_set in point_sets[1:]:
            if point_set.shape[1] != dim:
                raise ValueError('All points need to be from the same dimension')

        a_mat_blocks: list[np.ndarray] = []
        b_vec_blocks: list[np.ndarray] = []
        for i, points in enumerate(point_sets):
            a_mat_blocks.append(GeometryUtils.one_hot_embedding(k, i, points))
            b_vec_blocks.append(np.array([(pt ** 2).sum() / 2 for pt in points]))
        a_mat = np.concatenate(a_mat_blocks)
        b_vec = np.concatenate(b_vec_blocks)
        z, ker = LinAlgUtils.solve(a_mat, b_vec)

        TimingUtils().stop("Geom :: Construct Equispace")
        return z[:dim], ker[:, :dim]

    @staticmethod
    def one_hot_embedding(number_of_categories: int, category: int, points: np.ndarray) -> np.ndarray:
        TimingUtils().start("Geom :: One Hot Embedding")
        if category >= number_of_categories:
            raise ValueError(f'Category out of range: need category < number_of_categories')
        suffix = np.zeros((len(points), number_of_categories))
        suffix[:, category] = 1
        one_hot_embedding = np.concatenate([points, suffix], axis=1)
        TimingUtils().stop("Geom :: One Hot Embedding")
        return one_hot_embedding

    @staticmethod
    def reflect_points_through_affine_space(shift: np.ndarray, vector_space: np.ndarray, *points: np.ndarray):
        TimingUtils().start("Geom :: Reflect Points Through Aff")
        u_mat = LinAlgUtils.orthogonalize_rows(vector_space).transpose()  # matrix with orthogonal columns
        trans_mat = 2 * u_mat @ u_mat.transpose() - np.identity(u_mat.shape[0])
        reflected_points = np.array([trans_mat @ (pt - shift) + shift for pt in points])
        TimingUtils().stop("Geom :: Reflect Points Through Aff")
        return reflected_points

    @staticmethod
    def circumsphere_of_weighted_points(points: np.ndarray, weights: np.ndarray) -> tuple[np.ndarray, float]:
        """Return center and power distance radius of the circumsphere of given weighted points. It lies in affine space
        generated by the points."""
        TimingUtils().start("Geom :: Circumsphere Of Weighted Points")
        if not (len(points.shape) == 2 and len(weights.shape) == 1 and points.shape[0] == weights.shape[0]):
            raise ValueError("Shape mismatch: points need to be a 2D array, and weights a 1D array of the same length")
        if len(points) == 0:
            raise ValueError("At least one point needs to be given.")
        if len(points) == 1:
            return points[0], weights[0]

        a_mat_t = points[1:] - points[0]  # difference vectors in row
        a_mat = a_mat_t.transpose()  # difference vectors in columns
        b_vec = (np.square(a_mat).sum(axis=0) + weights[1:] - weights[0]) / 2  # i-th entry: (||pi-p0||^2 + wi - w0)/2
        eq_mat = a_mat_t @ a_mat
        try:
            x = np.linalg.solve(eq_mat, b_vec)
        except np.linalg.LinAlgError:
            x, *_ = np.linalg.lstsq(eq_mat, b_vec)
            if not np.allclose(eq_mat @ x, b_vec):
                raise np.linalg.LinAlgError('Linear equation has no solution; check for degeneracies in the point set.')
        y = a_mat @ x
        rad2 = np.square(y).sum() + weights[0]
        z = y + points[0]

        TimingUtils().stop("Geom :: Circumsphere Of Weighted Points")
        return z, rad2
